// comfyui.js - VCP Plugin for ComfyUI
// Author: Gemini

const fs = require('fs').promises;
const path = require('path');
const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');

// --- Configuration --- //

async function loadConfig() {
    // Â∞ùËØïËØªÂèñÈÖçÁΩÆÊñá‰ª∂
    let serverInputDir = path.join(__dirname, 'input');
    try {
        const configContent = await fs.readFile(path.join(__dirname, 'config.env'), 'utf8');
        const lines = configContent.split('\n');
        for (const line of lines) {
            if (line.startsWith('COMFYUI_SERVER_INPUT_DIR=')) {
                serverInputDir = line.split('=')[1].trim();
                break;
            }
        }
    } catch (error) {
        console.error('[ComfyUI] Warning: Could not read config.env, using default input directory');
    }
    
    const config = {
        baseUrl: process.env.COMFYUI_BASE_URL || 'http://127.0.0.1:8188',
        clientId: process.env.COMFYUI_CLIENT_ID || uuidv4(),
        serverInputDir: serverInputDir,
        fileServerIp: process.env.FILE_SERVER_PUBLIC_IP || '172.30.93.161',
        fileServerPort: process.env.FILE_SERVER_PORT || '5974',
        fileServerKey: process.env.FILE_SERVER_ACCESS_KEY || '123456'
    };
    if (config.baseUrl.endsWith('/')) {
        config.baseUrl = config.baseUrl.slice(0, -1);
    }
    return config;
}

let CONFIG = null;
const WORKFLOW_DIR = path.join(__dirname, 'workflows');
const OUTPUT_DIR = path.join(__dirname, 'output');

async function initConfig() {
    if (!CONFIG) {
        CONFIG = await loadConfig();
    }
    return CONFIG;
}

// --- ComfyUI API Client --- //

async function get(urlPath) {
    const config = await initConfig();
    const response = await fetch(`${config.baseUrl}${urlPath}`);
    if (!response.ok) throw new Error(`API GET request failed for ${urlPath}: ${response.status}`);
    return response.json();
}

async function post(urlPath, body) {
    const config = await initConfig();
    const response = await fetch(`${config.baseUrl}${urlPath}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
    });
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API POST request failed for ${urlPath}: ${response.status}\n${errorText}`);
    }
    return response.json();
}

async function getImage(filename, subfolder, type = 'output') {
    const config = await initConfig();
    const url = `${config.baseUrl}/view?filename=${encodeURIComponent(filename)}&subfolder=${encodeURIComponent(subfolder)}&type=${type}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to get image: ${response.status}`);
    const buffer = await response.arrayBuffer();
    return Buffer.from(buffer);
}

async function downloadImageToInput(imageUrl, filename) {
    try {
        const response = await fetch(imageUrl);
        if (!response.ok) throw new Error(`Failed to download image: ${response.status}`);
        const buffer = await response.arrayBuffer();
        const imageBuffer = Buffer.from(buffer);
        
        // ‰øùÂ≠òÂà∞ComfyUIÁöÑinputÁõÆÂΩï
        const inputDir = path.join(__dirname, 'input');
        await fs.mkdir(inputDir, { recursive: true });
        const inputPath = path.join(inputDir, filename);
        await fs.writeFile(inputPath, imageBuffer);
        
        console.error(`[ComfyUI] Downloaded image to input: ${filename}`);
        return filename;
    } catch (error) {
        console.error(`[ComfyUI] Failed to download image: ${error.message}`);
        throw error;
    }
}

async function copyLocalImageToInput(imagePath, filename) {
    try {
        const config = await initConfig();
        
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÁªùÂØπË∑ØÂæÑ
        let absolutePath = imagePath;
        if (!path.isAbsolute(imagePath)) {
            // Â¶ÇÊûúÊòØÁõ∏ÂØπË∑ØÂæÑÔºåÂ∞ùËØïÂú®attachmentsÁõÆÂΩï‰∏≠Êü•Êâæ
            const attachmentsDir = path.join(__dirname, '..', '..', '..', 'AppData', 'UserData', 'attachments');
            absolutePath = path.join(attachmentsDir, imagePath);
        }
        
        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
        try {
            await fs.access(absolutePath);
        } catch (accessError) {
            throw new Error(`Image file not found: ${absolutePath}`);
        }
        
        // ËØªÂèñÂõæÁâáÊñá‰ª∂
        const imageBuffer = await fs.readFile(absolutePath);
        
        // ‰øùÂ≠òÂà∞Êèí‰ª∂Êú¨Âú∞ÁöÑinputÁõÆÂΩï
        const localInputDir = path.join(__dirname, 'input');
        await fs.mkdir(localInputDir, { recursive: true });
        const localInputPath = path.join(localInputDir, filename);
        await fs.writeFile(localInputPath, imageBuffer);
        
        // ÂêåÊó∂‰øùÂ≠òÂà∞ComfyUIÊúçÂä°Âô®ÁöÑinputÁõÆÂΩï
        const serverInputDir = config.serverInputDir;
        await fs.mkdir(serverInputDir, { recursive: true });
        const serverInputPath = path.join(serverInputDir, filename);
        await fs.writeFile(serverInputPath, imageBuffer);
        
        console.error(`[ComfyUI] Copied local image to both local and server input: ${filename} (from: ${absolutePath})`);
        console.error(`[ComfyUI] Local path: ${localInputPath}`);
        console.error(`[ComfyUI] Server path: ${serverInputPath}`);
        return filename;
    } catch (error) {
        console.error(`[ComfyUI] Failed to copy local image: ${error.message}`);
        throw error;
    }
}

async function checkIfImageExistsInAttachments(imagePath) {
    try {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÁõ∏ÂØπË∑ØÂæÑ
        if (path.isAbsolute(imagePath)) {
            return false;
        }
        
        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Âú®attachmentsÁõÆÂΩï‰∏≠Â≠òÂú®
        const attachmentsDir = path.join(__dirname, '..', '..', '..', 'AppData', 'UserData', 'attachments');
        const absolutePath = path.join(attachmentsDir, imagePath);
        
        try {
            await fs.access(absolutePath);
            return true;
        } catch (accessError) {
            return false;
        }
    } catch (error) {
        return false;
    }
}

async function getAttachmentImageUrl(imagePath) {
    const config = await initConfig();
    // ËøîÂõûÈÄöËøáInputServerËÆøÈóÆattachmentsÁõÆÂΩïÁöÑURL
    return `http://${config.fileServerIp}:${config.fileServerPort}/comfyui_server/pw=${config.fileServerKey}/files/attachments/${imagePath}`;
}

async function queuePrompt(prompt) {
    const config = await initConfig();
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(`${config.baseUrl.replace('http', 'ws')}/ws?clientId=${config.clientId}`);
        let promptId = null;
        ws.on('open', async () => {
            try {
                console.error('[ComfyUI] WebSocket opened, queueing prompt...');
                const response = await post('/prompt', { prompt, client_id: CONFIG.clientId });
                promptId = response.prompt_id;
                console.error(`[ComfyUI] Prompt queued with ID: ${promptId}`);
            } catch (err) { reject(err); ws.close(); }
        });
        ws.on('message', async (data, isBinary) => {
            if (isBinary) { console.error('[ComfyUI] Received binary message, ignoring.'); return; }
            const msg = JSON.parse(data.toString());
            if (msg.type === 'executing' && msg.data.node === null && msg.data.prompt_id === promptId) {
                console.error('[ComfyUI] Execution finished.');
                ws.close();
                try {
                    const history = await get(`/history/${promptId}`);
                    const historyData = history[promptId];
                    const outputs = historyData.outputs;
                    const saveImageNodeId = Object.keys(outputs).find(key => outputs[key].images);
                    if (!saveImageNodeId || !outputs[saveImageNodeId].images) throw new Error('Could not find image output in history.');
                    resolve(outputs[saveImageNodeId].images);
                } catch (err) { reject(err); }
            } else if (msg.type === 'execution_error') {
                reject(new Error(`Execution failed: ${JSON.stringify(msg.data.exception_message)}`));
                ws.close();
            }
        });
        ws.on('error', (err) => { reject(err); });
        ws.on('close', () => { console.error('[ComfyUI] WebSocket closed.'); });
    });
}

// --- Workflow Conversion Functions --- //

// ÂØºÂÖ•ÈÄöÁî®ËäÇÁÇπÈÄÇÈÖçÂô®ÂíåÊô∫ËÉΩÂèÇÊï∞‰øÆÊîπÂô®
const {
    generateSmartNodeTitle,
    extractSmartParameters,
    convertWorkflowToUniversalFormat,
    generateNodeTypeReport
} = require('./universal_node_adapter.js');

const {
    createSmartParameterModifier,
    findNodesSmartly,
    findBestParameterMatch
} = require('./smart_parameter_modifier.js');

// ËΩ¨Êç¢ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ†ºÂºè‰∏∫APIÊ†ºÂºèÔºà‰ΩøÁî®ÈÄöÁî®ÈÄÇÈÖçÂô®Ôºâ
function convertFullWorkflowToApiFormat(fullWorkflow) {
    console.log('[ComfyUI] ‰ΩøÁî®ÈÄöÁî®ËäÇÁÇπÈÄÇÈÖçÂô®ËΩ¨Êç¢Â∑•‰ΩúÊµÅ...');
    
    // ÁîüÊàêËäÇÁÇπÁ±ªÂûãÊä•Âëä
    const report = generateNodeTypeReport(fullWorkflow);
    console.log(`[ComfyUI] Â∑•‰ΩúÊµÅÂàÜÊûê: ${report.total_nodes}‰∏™ËäÇÁÇπ, ${report.total_types}ÁßçÁ±ªÂûã`);
    console.log(`[ComfyUI] ÊîØÊåÅÁöÑËäÇÁÇπÁ±ªÂûã: ${report.supported_types.length}‰∏™`);
    console.log(`[ComfyUI] ‰∏çÊîØÊåÅÁöÑËäÇÁÇπÁ±ªÂûã: ${report.unsupported_types.length}‰∏™`);
    
    if (report.unsupported_types.length > 0) {
        console.log('[ComfyUI] ‰∏çÊîØÊåÅÁöÑËäÇÁÇπÁ±ªÂûã:', report.unsupported_types.join(', '));
    }
    
    // ‰ΩøÁî®ÈÄöÁî®ÈÄÇÈÖçÂô®ËΩ¨Êç¢Â∑•‰ΩúÊµÅ
    return convertWorkflowToUniversalFormat(fullWorkflow);
}

// --- Plugin Logic --- //

function findNodeByTitle(prompt, title) {
    for (const id in prompt) { if (prompt[id]._meta?.title === title) return prompt[id]; }
    return null;
}

// Ëé∑ÂèñÂèØÁî®ÈÄâÈ°π
async function getAvailableOptions(itemType) {
    try {
        const objectInfo = await get('/object_info');
        
        switch (itemType) {
            case 'model':
                return objectInfo.CheckpointLoaderSimple?.input?.required?.ckpt_name?.[0] || [];
            case 'lora':
                return objectInfo.LoraLoader?.input?.required?.lora_name?.[0] || [];
            case 'vae':
                return objectInfo.VAELoader?.input?.required?.vae_name?.[0] || [];
            case 'controlnet':
                return objectInfo.ControlNetLoader?.input?.required?.control_net_name?.[0] || [];
            case 'sampler':
                return objectInfo.KSampler?.input?.required?.sampler_name?.[0] || [];
            case 'scheduler':
                return objectInfo.KSampler?.input?.required?.scheduler?.[0] || [];
            default:
                return [];
        }
    } catch (error) {
        console.error(`[ComfyUI] Ëé∑Âèñ${itemType}ÈÄâÈ°πÂ§±Ë¥•: ${error.message}`);
        return [];
    }
}

// ÈÄöÁî®Êô∫ËÉΩÂåπÈÖçÂáΩÊï∞
async function findBestMatch(requested, availableItems, itemType = 'item') {
    // Ê£ÄÊü•ÊòØÂê¶Â≠òÂú®Á≤æÁ°ÆÂåπÈÖç
    if (availableItems.includes(requested)) {
        return requested;
    }
    
    console.error(`[ComfyUI] ${itemType} '${requested}' ‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÊô∫ËÉΩÂåπÈÖç...`);
    
    const requestedLower = requested.toLowerCase();
    const matches = [];
    
    for (const item of availableItems) {
        const itemLower = item.toLowerCase();
        let score = 0;
        
        // ÂÆåÂÖ®ÂåπÈÖçÔºàÂøΩÁï•Â§ßÂ∞èÂÜôÔºâ
        if (itemLower === requestedLower) score += 100;
        
        // ÂåÖÂê´ÂåπÈÖç
        if (itemLower.includes(requestedLower) || requestedLower.includes(itemLower)) score += 50;
        
        // ÊãºÂÜôÁõ∏‰ººÂ∫¶
        const distance = calculateLevenshteinDistance(itemLower, requestedLower);
        const maxLength = Math.max(itemLower.length, requestedLower.length);
        const similarity = 1 - (distance / maxLength);
        score += similarity * 30;
        
        // Êñá‰ª∂ÂêçÁâπÂÆöÂåπÈÖçÔºàÈíàÂØπÊ®°ÂûãÊñá‰ª∂Ôºâ
        if (itemType === 'model') {
            // ÁßªÈô§Êâ©Â±ïÂêçËøõË°åÊØîËæÉ
            const itemNoExt = itemLower.replace(/\.(safetensors|ckpt|pt|pth|bin)$/i, '');
            const requestedNoExt = requestedLower.replace(/\.(safetensors|ckpt|pt|pth|bin)$/i, '');
            
            if (itemNoExt === requestedNoExt) score += 80;
            if (itemNoExt.includes(requestedNoExt) || requestedNoExt.includes(itemNoExt)) score += 40;
            
            // ÁâàÊú¨Âè∑ÂåπÈÖç
            const versionMatch = itemNoExt.match(/v\d+(\.\d+)*/);
            const versionMatchRequested = requestedNoExt.match(/v\d+(\.\d+)*/);
            if (versionMatch && versionMatchRequested && versionMatch[0] === versionMatchRequested[0]) {
                score += 25;
            }
            
            // Â¢ûÂº∫ÁöÑÂÖ≥ÈîÆËØçÂåπÈÖç
            const modelKeywords = [
                'sd', 'xl', 'base', 'refiner', 'v1', 'v2', 'v3', 'v4', 'v5', 'v6',
                'anime', 'realistic', 'realistic', 'checkpoint', 'real', 'vision', 'epic', 'deliberate',
                'dreamshaper', 'juggernaut', 'realisticvision', 'epicrealism'
            ];
            for (const keyword of modelKeywords) {
                if (itemNoExt.includes(keyword) && requestedNoExt.includes(keyword)) {
                    score += 15;
                }
            }
        }
        
        // LoRAÁâπÂÆöÂåπÈÖç
        if (itemType === 'lora') {
            const itemNoExt = itemLower.replace(/\.(safetensors|pt|pth)$/i, '');
            const requestedNoExt = requestedLower.replace(/\.(safetensors|pt|pth)$/i, '');
            
            if (itemNoExt === requestedNoExt) score += 80;
            if (itemNoExt.includes(requestedNoExt) || requestedNoExt.includes(itemNoExt)) score += 40;
            
            // LoRAÂÖ≥ÈîÆËØçÂåπÈÖç
            const loraKeywords = ['lora', 'style', 'character', 'concept', 'clothing', 'epic', 'realistic'];
            for (const keyword of loraKeywords) {
                if (itemNoExt.includes(keyword) && requestedNoExt.includes(keyword)) {
                    score += 15;
                }
            }
        }
        
        // VAEÁâπÂÆöÂåπÈÖç
        if (itemType === 'vae') {
            const itemNoExt = itemLower.replace(/\.(safetensors|ckpt|pt|pth)$/i, '');
            const requestedNoExt = requestedLower.replace(/\.(safetensors|ckpt|pt|pth)$/i, '');
            
            if (itemNoExt === requestedNoExt) score += 80;
            if (itemNoExt.includes(requestedNoExt) || requestedNoExt.includes(itemNoExt)) score += 40;
            
            // VAEÂÖ≥ÈîÆËØçÂåπÈÖç
            const vaeKeywords = ['vae', 'mse', 'ema', 'pruned', 'ft', 'sdxl'];
            for (const keyword of vaeKeywords) {
                if (itemNoExt.includes(keyword) && requestedNoExt.includes(keyword)) {
                    score += 15;
                }
            }
        }
        
        // ControlNetÁâπÂÆöÂåπÈÖç
        if (itemType === 'controlnet') {
            const itemNoExt = itemLower.replace(/\.(safetensors|pt|pth)$/i, '');
            const requestedNoExt = requestedLower.replace(/\.(safetensors|pt|pth)$/i, '');
            
            if (itemNoExt === requestedNoExt) score += 80;
            if (itemNoExt.includes(requestedNoExt) || requestedNoExt.includes(itemNoExt)) score += 40;
            
            // ControlNetÂÖ≥ÈîÆËØçÂåπÈÖç
            const controlnetKeywords = ['control', 'canny', 'depth', 'openpose', 'scribble', 'mlsd'];
            for (const keyword of controlnetKeywords) {
                if (itemNoExt.includes(keyword) && requestedNoExt.includes(keyword)) {
                    score += 15;
                }
            }
        }
        
        if (score > 0) {
            matches.push({ item, score, similarity });
        }
    }
    
    // ÊåâÂàÜÊï∞ÊéíÂ∫è
    matches.sort((a, b) => b.score - a.score);
    
    if (matches.length > 0) {
        const bestMatch = matches[0];
        console.error(`[ComfyUI] ÊâæÂà∞ÊúÄ‰Ω≥${itemType}ÂåπÈÖç: ${bestMatch.item} (ÂàÜÊï∞: ${bestMatch.score.toFixed(1)}, Áõ∏‰ººÂ∫¶: ${bestMatch.similarity.toFixed(3)})`);
        
        // Â¶ÇÊûúÊúâÂ§ö‰∏™ÂåπÈÖçÔºåÊòæÁ§∫ÂâçÂá†‰∏™ÈÄâÈ°π
        if (matches.length > 1) {
            console.error(`[ComfyUI] ÂÖ∂‰ªñ${itemType}ÂåπÈÖçÈÄâÈ°π:`);
            matches.slice(1, 4).forEach(match => {
                console.error(`  - ${match.item} (ÂàÜÊï∞: ${match.score.toFixed(1)}, Áõ∏‰ººÂ∫¶: ${match.similarity.toFixed(3)})`);
            });
        }
        
        // Âè™ÊúâÂΩìÂàÜÊï∞Ë∂≥Â§üÈ´òÊó∂ÊâçËøîÂõûÂåπÈÖç
        if (bestMatch.score >= 50) {
            return bestMatch.item;
        } else {
            console.error(`[ComfyUI] ÊúÄ‰Ω≥ÂåπÈÖçÂàÜÊï∞Ëøá‰Ωé (${bestMatch.score.toFixed(1)}), ÈúÄË¶ÅÊõ¥Á≤æÁ°ÆÁöÑÂåπÈÖç`);
        }
    }
    
    // Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÔºåÊòæÁ§∫ÂèØÁî®ÈÄâÈ°π
    console.error(`[ComfyUI] Êú™ÊâæÂà∞ÂåπÈÖçÁöÑ${itemType}`);
    console.error(`[ComfyUI] ÂèØÁî®ÁöÑ${itemType}ÈÄâÈ°π (Ââç10‰∏™):`);
    availableItems.slice(0, 10).forEach(item => {
        console.error(`  - ${item}`);
    });
    if (availableItems.length > 10) {
        console.error(`  ... ËøòÊúâ ${availableItems.length - 10} ‰∏™ÈÄâÈ°π`);
    }
    
    throw new Error(`${itemType} '${requested}' not found. Available ${itemType}s: ${availableItems.length} options`);
}

// Êô∫ËÉΩÂ∑•‰ΩúÊµÅÂêçÁß∞ÂåπÈÖç
async function findMatchingWorkflow(requestedName) {
    try {
        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
        const workflowPath = path.join(WORKFLOW_DIR, requestedName);
        await fs.access(workflowPath);
        return requestedName; // Êñá‰ª∂Â≠òÂú®ÔºåÁõ¥Êé•ËøîÂõû
    } catch (error) {
        // Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÊô∫ËÉΩÂåπÈÖç
        console.error(`[ComfyUI] Â∑•‰ΩúÊµÅÊñá‰ª∂‰∏çÂ≠òÂú®: ${requestedName}ÔºåÂ∞ùËØïÊô∫ËÉΩÂåπÈÖç...`);
        
        try {
            const files = await fs.readdir(WORKFLOW_DIR);
            const workflowFiles = files.filter(f => f.endsWith('.json'));
            
            // Êô∫ËÉΩÂåπÈÖçÁÆóÊ≥ï
            const requested = requestedName.toLowerCase().replace('.json', '');
            const matches = [];
            
            for (const file of workflowFiles) {
                const fileName = file.toLowerCase().replace('.json', '');
                let score = 0;
                
                // ÂÆåÂÖ®ÂåπÈÖç
                if (fileName === requested) score += 100;
                
                // ÂåÖÂê´ÂåπÈÖç
                if (fileName.includes(requested) || requested.includes(fileName)) score += 50;
                
                // ÊãºÂÜôÁõ∏‰ººÂ∫¶
                const distance = calculateLevenshteinDistance(fileName, requested);
                const maxLength = Math.max(fileName.length, requested.length);
                const similarity = 1 - (distance / maxLength);
                score += similarity * 30;
                
                // ÂÖ≥ÈîÆËØçÂåπÈÖç
                const keywords = ['text', 'txt', 'img', 'image', 'inpaint', 'control', 'upscale', 'api'];
                for (const keyword of keywords) {
                    if (fileName.includes(keyword) && requested.includes(keyword)) {
                        score += 20;
                    }
                }
                
                if (score > 0) {
                    matches.push({ file, score, fileName });
                }
            }
            
            // ÊåâÂàÜÊï∞ÊéíÂ∫è
            matches.sort((a, b) => b.score - a.score);
            
            if (matches.length > 0) {
                const bestMatch = matches[0];
                console.error(`[ComfyUI] ÊâæÂà∞ÊúÄ‰Ω≥ÂåπÈÖç: ${bestMatch.file} (ÂàÜÊï∞: ${bestMatch.score.toFixed(1)})`);
                
                // Â¶ÇÊûúÊúâÂ§ö‰∏™ÂåπÈÖçÔºåÊòæÁ§∫ÂâçÂá†‰∏™ÈÄâÈ°π
                if (matches.length > 1) {
                    console.error(`[ComfyUI] ÂÖ∂‰ªñÂåπÈÖçÈÄâÈ°π:`);
                    matches.slice(1, 4).forEach(match => {
                        console.error(`  - ${match.file} (ÂàÜÊï∞: ${match.score.toFixed(1)})`);
                    });
                }
                
                return bestMatch.file;
            }
            
            // Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÔºåÊòæÁ§∫ÂèØÁî®Êñá‰ª∂
            console.error(`[ComfyUI] Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÂ∑•‰ΩúÊµÅÊñá‰ª∂`);
            console.error(`[ComfyUI] ÂèØÁî®ÁöÑÂ∑•‰ΩúÊµÅÊñá‰ª∂:`);
            workflowFiles.forEach(file => {
                console.error(`  - ${file}`);
            });
            
            throw new Error(`Workflow file '${requestedName}' not found. Available files: ${workflowFiles.join(', ')}`);
            
        } catch (error) {
            throw new Error(`Cannot find workflow file '${requestedName}': ${error.message}`);
        }
    }
}

// ËÆ°ÁÆóÁºñËæëË∑ùÁ¶ªÔºàLevenshteinË∑ùÁ¶ªÔºâ
function calculateLevenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

function generateFilenameFromPrompt(promptText) {
    if (!promptText || typeof promptText !== 'string') {
        return 'ComfyUI';
    }
    
    // Ê∏ÖÁêÜÂíåÁÆÄÂåñÊèêÁ§∫ËØç
    let cleanText = promptText
        .toLowerCase()
        .replace(/[^\w\s\u4e00-\u9fff,-]/g, ' ') // ‰øùÁïô‰∏≠Êñá„ÄÅËã±Êñá„ÄÅÊï∞Â≠ó„ÄÅÁ©∫Ê†º„ÄÅÈÄóÂè∑„ÄÅÊ®™Á∫ø
        .replace(/\s+/g, ' ')
        .trim();
    
    // ÊèêÂèñÂÖ≥ÈîÆ‰ø°ÊÅØ
    const keywords = [];
    
    // Â∏∏ËßÅËßíËâ≤/‰∫∫Áâ©ÂÖ≥ÈîÆËØç
    const characterKeywords = ['girl', 'boy', 'woman', 'man', 'character', 'person', '‰∫∫', 'Â•≥Â≠©', 'Áî∑Â≠©', 'Â•≥ÊÄß', 'Áî∑ÊÄß'];
    // Â∏∏ËßÅÈ£éÊ†ºÂÖ≥ÈîÆËØç  
    const styleKeywords = ['anime', 'realistic', 'cartoon', 'oil painting', 'watercolor', 'Âä®Êº´', 'ÂÜôÂÆû', 'Âç°ÈÄö', 'Ê≤πÁîª', 'Ê∞¥ÂΩ©'];
    // Â∏∏ËßÅÂú∫ÊôØÂÖ≥ÈîÆËØç
    const sceneKeywords = ['landscape', 'portrait', 'scenery', 'city', 'nature', 'È£éÊôØ', 'ËÇñÂÉè', 'ÂüéÂ∏Ç', 'Ëá™ÁÑ∂'];
    
    // Ê£ÄÊü•ÂÖ≥ÈîÆËØç
    const words = cleanText.split(' ').filter(word => word.length > 1);
    
    for (const word of words) {
        if (characterKeywords.some(kw => word.includes(kw)) || 
            styleKeywords.some(kw => word.includes(kw)) || 
            sceneKeywords.some(kw => word.includes(kw)) ||
            word.length <= 10) { // ÈôêÂà∂ÈïøÂ∫¶
            keywords.push(word);
        }
        if (keywords.length >= 3) break; // ÈôêÂà∂ÂÖ≥ÈîÆËØçÊï∞Èáè
    }
    
    // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÂÖ≥ÈîÆËØçÔºå‰ΩøÁî®ÁÆÄÂåñÁöÑÊèêÁ§∫ËØç
    if (keywords.length === 0) {
        const shortText = cleanText.split(' ').slice(0, 3).join('_');
        return shortText.length > 20 ? shortText.substring(0, 20) : shortText || 'ComfyUI';
    }
    
    return keywords.join('_');
}

async function handleGetInfo(args) {
    const type = args.info.toLowerCase();
    let data, title, formattter;
    switch (type) {
        case 'workflows':
            const files = await fs.readdir(WORKFLOW_DIR);
            data = files.filter(f => f.endsWith('.json'));
            title = 'üìÑ ÂèØÁî®Â∑•‰ΩúÊµÅ';
            formattter = item => `- **${item}**`;
            break;
        case 'checkpoints':
            // ‰ΩøÁî® ComfyUImodules ‰∏≠ÁöÑÊñπÊ≥ïËé∑Âèñ checkpoints
            const objectInfo = await get('/object_info');
            const checkpoints = objectInfo.CheckpointLoaderSimple?.input?.required?.ckpt_name?.[0] || [];
            data = checkpoints;
            title = 'üì¶ ÂèØÁî® Checkpoint Ê®°Âûã';
            formattter = item => `- **${item}**`;
            break;
        case 'loras':
            const loraInfo = await get('/object_info');
            const loras = loraInfo.LoraLoader?.input?.required?.lora_name?.[0] || [];
            data = loras;
            title = 'üì¶ ÂèØÁî® LoRA Ê®°Âûã';
            formattter = item => `- **${item}**`;
            break;
        case 'vaes':
            const vaeInfo = await get('/object_info');
            const vaes = vaeInfo.VAELoader?.input?.required?.vae_name?.[0] || [];
            data = vaes;
            title = 'üì¶ ÂèØÁî® VAE Ê®°Âûã';
            formattter = item => `- **${item}**`;
            break;
        case 'samplers':
            const samplerInfo = await get('/object_info');
            const samplers = samplerInfo.KSampler?.input?.required?.sampler_name?.[0] || [];
            data = samplers;
            title = 'üì¶ ÂèØÁî®ÈááÊ†∑Âô®';
            formattter = item => `- **${item}**`;
            break;
        case 'schedulers':
            const schedulerInfo = await get('/object_info');
            const schedulers = schedulerInfo.KSampler?.input?.required?.scheduler?.[0] || [];
            data = schedulers;
            title = 'üì¶ ÂèØÁî®Ë∞ÉÂ∫¶Âô®';
            formattter = item => `- **${item}**`;
            break;
        default: throw new Error(`Invalid info type: ${args.info}`);
    }
    if (!Array.isArray(data)) throw new Error(`Could not construct a list for info type '${args.info}'.`);
    const list = data.map(formattter).join('\n');
    const resultText = `### ${title}\n\n${list}`;
    return { content: [{ type: 'text', text: resultText }] };
}

async function handleRunWorkflow(args) {
    let workflowFile = args.workflow;
    if (!workflowFile.endsWith('.json')) throw new Error('Workflow file must be a .json file.');
    
    // Êô∫ËÉΩÂ∑•‰ΩúÊµÅÂêçÁß∞ÂåπÈÖç
    const matchedFile = await findMatchingWorkflow(workflowFile);
    if (matchedFile !== workflowFile) {
        console.error(`[ComfyUI] Êô∫ËÉΩÂåπÈÖçÂ∑•‰ΩúÊµÅ: ${workflowFile} -> ${matchedFile}`);
        workflowFile = matchedFile;
    }
    
    const workflowPath = path.join(WORKFLOW_DIR, workflowFile);
    const workflowJson = await fs.readFile(workflowPath, 'utf-8');
    const workflowData = JSON.parse(workflowJson);
    
    // ComfyUIÂ∑•‰ΩúÊµÅÊñá‰ª∂ÁöÑÁªìÊûÑÂèØËÉΩÊúâ‰∏âÁßçÔºö
    // 1. Áõ¥Êé•ÂåÖÂê´ËäÇÁÇπÂØπË±°ÔºàAPIÊ†ºÂºèÔºâ
    // 2. ÂåÖË£ÖÂú®promptÂ±ûÊÄß‰∏≠ÔºàAPIÊ†ºÂºèÔºâ
    // 3. ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ†ºÂºèÔºàÂåÖÂê´nodesÊï∞ÁªÑÔºâ
    let prompt;
    
    if (workflowData.nodes && Array.isArray(workflowData.nodes)) {
        // ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ†ºÂºè - ÈúÄË¶ÅËΩ¨Êç¢‰∏∫APIÊ†ºÂºè
        prompt = convertFullWorkflowToApiFormat(workflowData);
    } else {
        // APIÊ†ºÂºè
        prompt = workflowData.prompt || workflowData;
    }
    
    // È™åËØÅpromptÂØπË±°ÊòØÂê¶Â≠òÂú®
    if (!prompt || typeof prompt !== 'object') {
        throw new Error(`Workflow file '${workflowFile}' does not contain a valid prompt object`);
    }
    
    if (args.prompt && !args.params) {
        args.params = [{ node_title: "Positive Prompt", inputs: { text: args.prompt } }];
    }
    let params = args.params || [];
    
    // Â§ÑÁêÜÂ≠óÁ¨¶‰∏≤ÂåñÁöÑJSONÂèÇÊï∞
    if (typeof params === 'string') {
        try {
            params = JSON.parse(params);
        } catch (e) {
            console.error('[ComfyUI] Failed to parse stringified params:', e);
            throw new Error('Invalid params format: could not parse JSON string');
        }
    }
    
    if (Array.isArray(params)) {
        console.log('[ComfyUI] ‰ΩøÁî®Êô∫ËÉΩÂèÇÊï∞‰øÆÊîπÂô®Â§ÑÁêÜÂèÇÊï∞...');
        
        // ÂàõÂª∫Êô∫ËÉΩÂèÇÊï∞‰øÆÊîπÂô®
        const smartModifier = createSmartParameterModifier(prompt);
        
        for (const patch of params) {
            let targetNode = null;
            
            // È¶ñÂÖàÂ∞ùËØï‰º†ÁªüÊñπÊ≥ï
            if (patch.node_title) { 
                targetNode = findNodeByTitle(prompt, patch.node_title); 
            } else if (patch.node_id) { 
                targetNode = prompt[patch.node_id]; 
            }
            
            // Â¶ÇÊûú‰º†ÁªüÊñπÊ≥ïÂ§±Ë¥•Ôºå‰ΩøÁî®Êô∫ËÉΩÊü•Êâæ
            if (!targetNode && patch.node_title) {
                console.log(`[ComfyUI] ‰º†ÁªüÊü•ÊâæÂ§±Ë¥•Ôºå‰ΩøÁî®Êô∫ËÉΩÊü•Êâæ: ${patch.node_title}`);
                const smartResults = findNodesSmartly(prompt, patch.node_title);
                if (smartResults.length > 0) {
                    targetNode = smartResults[0].node;
                    console.log(`[ComfyUI] Êô∫ËÉΩÊü•ÊâæÊàêÂäü: ${smartResults[0].nodeId} (${targetNode._meta.title})`);
                }
            }
            
            if (!targetNode) { 
                console.error(`[ComfyUI] Warning: Could not find node for patch:`, patch); 
                
                // ÊòæÁ§∫ÂèØÁî®ÁöÑËäÇÁÇπ‰ø°ÊÅØ
                console.error(`[ComfyUI] Available node titles:`, Object.keys(prompt).map(id => prompt[id]._meta?.title).filter(Boolean));
                console.error(`[ComfyUI] All node IDs and class types:`, Object.keys(prompt).map(id => ({ id, class_type: prompt[id].class_type, title: prompt[id]._meta?.title })));
                
                // Â∞ùËØïÊô∫ËÉΩÂª∫ËÆÆ
                const suggestions = findNodesSmartly(prompt, patch.node_title);
                if (suggestions.length > 0) {
                    console.error(`[ComfyUI] Êô∫ËÉΩÂª∫ËÆÆ:`);
                    suggestions.slice(0, 3).forEach(suggestion => {
                        console.error(`  - ${suggestion.nodeId}: ${suggestion.node._meta.title} (Áõ∏ÂÖ≥ÊÄß: ${suggestion.relevance})`);
                    });
                }
                
                continue; 
            }
            
            // ÁâπÊÆäÂ§ÑÁêÜLoadImageËäÇÁÇπÁöÑÂõæÁâá
            if (patch.node_title === 'Load Image' && patch.inputs.image) {
                const imageValue = patch.inputs.image;
                
                if (imageValue.startsWith('http://') || imageValue.startsWith('https://')) {
                    // Â§ÑÁêÜURLÂõæÁâá
                    try {
                        const filename = path.basename(new URL(imageValue).pathname);
                        const downloadedFilename = await downloadImageToInput(imageValue, filename);
                        patch.inputs.image = downloadedFilename;
                        console.error(`[ComfyUI] Converted URL to local file: ${imageValue} -> ${downloadedFilename}`);
                    } catch (error) {
                        console.error(`[ComfyUI] Failed to download image from URL: ${imageValue}`, error);
                        continue;
                    }
                } else {
                    // Â§ÑÁêÜÊú¨Âú∞ÂõæÁâáË∑ØÂæÑ
                    try {
                        // È¶ñÂÖàÊ£ÄÊü•ÊòØÂê¶Âú®attachmentsÁõÆÂΩï‰∏≠
                        const existsInAttachments = await checkIfImageExistsInAttachments(imageValue);
                        
                        if (existsInAttachments) {
                            // Â¶ÇÊûúÂú®attachmentsÁõÆÂΩï‰∏≠Ôºå‰ΩøÁî®InputServerÁöÑURL
                            const attachmentUrl = await getAttachmentImageUrl(imageValue);
                            const filename = path.basename(imageValue);
                            const downloadedFilename = await downloadImageToInput(attachmentUrl, filename);
                            patch.inputs.image = downloadedFilename;
                            console.error(`[ComfyUI] Using InputServer for attachment: ${imageValue} -> ${downloadedFilename}`);
                        } else {
                            // Âê¶Âàô‰ΩøÁî®‰º†ÁªüÂ§çÂà∂ÊñπÂºè
                            const filename = path.basename(imageValue);
                            const copiedFilename = await copyLocalImageToInput(imageValue, filename);
                            patch.inputs.image = copiedFilename;
                            console.error(`[ComfyUI] Copied local file to input: ${imageValue} -> ${copiedFilename}`);
                        }
                    } catch (error) {
                        console.error(`[ComfyUI] Failed to process local image: ${imageValue}`, error);
                        continue;
                    }
                }
            }
            
            // ‰ΩøÁî®Êô∫ËÉΩÂèÇÊï∞Â∫îÁî®
            let appliedCount = 0;
            for (const key in patch.inputs) {
                // È¶ñÂÖàÂ∞ùËØïÁ≤æÁ°ÆÂåπÈÖç
                if (targetNode.inputs.hasOwnProperty(key)) {
                    const oldValue = targetNode.inputs[key];
                    let newValue = patch.inputs[key];
                    
                    // ÂØπÁâπÂÆöÂèÇÊï∞Á±ªÂûãËøõË°åÊô∫ËÉΩÂåπÈÖç
                    if (key === 'ckpt_name' || key === 'lora_name' || key === 'vae_name' || key === 'control_net_name') {
                        try {
                            const itemType = key === 'ckpt_name' ? 'model' : 
                                          key === 'lora_name' ? 'lora' : 
                                          key === 'vae_name' ? 'vae' : 'controlnet';
                            
                            // Ëé∑ÂèñÂèØÁî®ÈÄâÈ°π
                            const availableOptions = await getAvailableOptions(itemType);
                            newValue = await findBestMatch(newValue, availableOptions, itemType);
                            console.error(`[ComfyUI] Êô∫ËÉΩ${itemType}ÂåπÈÖç: ${patch.inputs[key]} -> ${newValue}`);
                        } catch (error) {
                            console.error(`[ComfyUI] ${itemType}ÂåπÈÖçÂ§±Ë¥•: ${error.message}`);
                            continue; // Ë∑≥ËøáËøô‰∏™ÂèÇÊï∞
                        }
                    }
                    
                    targetNode.inputs[key] = newValue;
                    console.error(`[ComfyUI] Applied patch: ${patch.node_title || patch.node_id}.${key} = ${newValue} (was: ${oldValue})`);
                    appliedCount++;
                } else {
                    // Â∞ùËØïÊô∫ËÉΩÂèÇÊï∞ÂêçÂåπÈÖç
                    const matchedKey = findBestParameterMatch(key, Object.keys(targetNode.inputs));
                    if (matchedKey) {
                        const oldValue = targetNode.inputs[matchedKey];
                        let newValue = patch.inputs[key];
                        
                        // ÂØπÁâπÂÆöÂèÇÊï∞Á±ªÂûãËøõË°åÊô∫ËÉΩÂåπÈÖç
                        if (matchedKey === 'ckpt_name' || matchedKey === 'lora_name' || matchedKey === 'vae_name' || matchedKey === 'control_net_name') {
                            try {
                                const itemType = matchedKey === 'ckpt_name' ? 'model' : 
                                              matchedKey === 'lora_name' ? 'lora' : 
                                              matchedKey === 'vae_name' ? 'vae' : 'controlnet';
                                
                                // Ëé∑ÂèñÂèØÁî®ÈÄâÈ°π
                                const availableOptions = await getAvailableOptions(itemType);
                                newValue = await findBestMatch(newValue, availableOptions, itemType);
                                console.error(`[ComfyUI] Êô∫ËÉΩ${itemType}ÂåπÈÖç: ${patch.inputs[key]} -> ${newValue}`);
                            } catch (error) {
                                console.error(`[ComfyUI] ${itemType}ÂåπÈÖçÂ§±Ë¥•: ${error.message}`);
                                continue; // Ë∑≥ËøáËøô‰∏™ÂèÇÊï∞
                            }
                        }
                        
                        targetNode.inputs[matchedKey] = newValue;
                        console.error(`[ComfyUI] Smart applied patch: ${patch.node_title || patch.node_id}.${matchedKey} = ${newValue} (was: ${oldValue}) [matched from '${key}']`);
                        appliedCount++;
                    } else {
                        console.error(`[ComfyUI] Warning: Node does not have an input named '${key}'. Available inputs:`, Object.keys(targetNode.inputs));
                    }
                }
            }
            
            if (appliedCount > 0) {
                console.error(`[ComfyUI] Successfully applied ${appliedCount} parameters to ${patch.node_title || patch.node_id}`);
            } else {
                console.error(`[ComfyUI] Warning: No parameters were applied to ${patch.node_title || patch.node_id}`);
            }
        }
    }
    
    // Âä®ÊÄÅÁîüÊàêÊñá‰ª∂ÂêçÂâçÁºÄ
    let filenamePrefix = 'ComfyUI';
    const positivePromptNode = findNodeByTitle(prompt, 'Positive Prompt');
    if (positivePromptNode && positivePromptNode.inputs && positivePromptNode.inputs.text) {
        const promptText = positivePromptNode.inputs.text;
        filenamePrefix = generateFilenameFromPrompt(promptText);
        console.error(`[ComfyUI] Generated filename prefix: ${filenamePrefix}`);
    }
    
    // Â∫îÁî®Êñá‰ª∂ÂêçÂâçÁºÄÂà∞SaveImageËäÇÁÇπ
    const saveImageNode = findNodeByTitle(prompt, 'Save Image');
    if (saveImageNode && saveImageNode.inputs) {
        const oldPrefix = saveImageNode.inputs.filename_prefix || 'ComfyUI';
        saveImageNode.inputs.filename_prefix = filenamePrefix;
        console.error(`[ComfyUI] Updated SaveImage prefix: ${oldPrefix} -> ${filenamePrefix}`);
    }
    
    // ËÆæÁΩÆÈöèÊú∫ÁßçÂ≠êÂà∞KSamplerËäÇÁÇπ
    const kSamplerNode = findNodeByTitle(prompt, 'KSampler');
    if (kSamplerNode && kSamplerNode.inputs && kSamplerNode.inputs.seed !== undefined) {
        const oldSeed = kSamplerNode.inputs.seed;
        const newSeed = Math.floor(Math.random() * 1000000000000000);
        kSamplerNode.inputs.seed = newSeed;
        console.error(`[ComfyUI] Updated KSampler seed: ${oldSeed} -> ${newSeed}`);
    }
    
    const outputImages = await queuePrompt(prompt);
    if (!outputImages || outputImages.length === 0) throw new Error('Workflow did not produce any images.');
    const firstImageInfo = outputImages[0];
    console.error(`[ComfyUI] ComfyUI generated image info:`, firstImageInfo);
    const filename = firstImageInfo.filename;
    const mountAlias = 'output'; // All generated images are in the output folder
    console.error(`[ComfyUI] Downloading image from ComfyUI: ${filename}`);
    const imageData = await getImage(filename, firstImageInfo.subfolder, firstImageInfo.type);
    console.error(`[ComfyUI] Image downloaded successfully. Size: ${imageData.length} bytes.`);
    await fs.mkdir(OUTPUT_DIR, { recursive: true });
    const savePath = path.join(OUTPUT_DIR, filename);
    console.error(`[ComfyUI] Saving image to absolute path: ${path.resolve(savePath)}`);
    await fs.writeFile(savePath, imageData);
    console.error(`[ComfyUI] Image saved successfully.`);
    const config = await initConfig();
    const fileUrl = `http://${config.fileServerIp}:${config.fileServerPort}/comfyui_server/pw=${config.fileServerKey}/files/${mountAlias}/${filename}`;
    const result = {
        content: [
            {
                type: 'text',
                text: `üéâ ÂõæÂÉèÂ∑≤ÈÄöËøáÂ∑•‰ΩúÊµÅ '${workflowFile}' ÊàêÂäüÁîüÊàêÔºÅ\n\n‚ú® **Â∫îÁî®ÂèÇÊï∞**:\n\`\`\`json\n${JSON.stringify(params, null, 2)}\n\`\`\`\n\nüìÇ **ËæìÂá∫Êñá‰ª∂**: ${filename}\n\n![ÁîüÊàêÁöÑÂõæÁâá](${fileUrl})`
            }
        ]
    };
    return result;
}

// --- Main Execution --- //

async function main() {
    let inputString = '';
    try {
        inputString = await new Promise((resolve) => {
            process.stdin.on('data', (chunk) => inputString += chunk);
            process.stdin.on('end', () => resolve(inputString.trim()));
        });
        if (!inputString) throw new Error('No input received from stdin.');
        const args = JSON.parse(inputString);
        let result;
        if (args.info) { result = await handleGetInfo(args); }
        else if (args.workflow) { result = await handleRunWorkflow(args); }
        else { throw new Error("Invalid command. Must provide either 'info' or 'workflow' parameter."); }
        console.log(JSON.stringify({ status: 'success', result }));
    } catch (e) {
        console.error(`[ComfyUI] Fatal Error: ${e.message}`);
        console.error(e.stack);
        console.log(JSON.stringify({ status: 'error', error: e.message }));
        process.exit(1);
    }
}

// ÂØºÂá∫ËΩ¨Êç¢ÂáΩÊï∞‰æõÊµãËØï‰ΩøÁî®
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        convertFullWorkflowToApiFormat,
        generateSmartNodeTitle,
        findNodeByTitle,
        findMatchingWorkflow,
        findBestMatch,
        getAvailableOptions,
        calculateLevenshteinDistance
    };
}

main();